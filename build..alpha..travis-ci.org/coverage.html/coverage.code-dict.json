{"/home/travis/build/npmtest/node-npmtest-app.js/test.js":"/* istanbul instrument in package npmtest_app_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-app.js/lib.npmtest_app.js.js":"/* istanbul instrument in package npmtest_app_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_app_js = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_app_js = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-app.js/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-app.js && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_app_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_app_js\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_app_js.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_app_js.rollup.js'] =\n            local.assetsDict['/assets.npmtest_app_js.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_app_js.__dirname +\n                    '/lib.npmtest_app_js.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-app.js/node_modules/app.js/lib/appjs.js":"\nvar fs = require('fs'),\n    path = require('path'),\n    ncp = require('ncp').ncp,\n    mkdirsSync = require('mkdir').mkdirsSync,\n    http = require('http'),\n    _ = require('underscore'),\n    async = require(\"async\"),\n    dandy = require(\"dandy/errors\"),\n    abind = require(\"dandy/errors\").abind,\n    ibind = require(\"dandy/errors\").ibind,\n    assert = require('assert').ok,\n    express = require('express'),\n    logger = require('express-logger'),\n    rewriter = require('express-rewrite'),\n    Cache = require('diskcache').Cache,\n    App = require('./App').App,\n    pkg = require('./pkg'),\n    utils = require('./utils');\n\n// *************************************************************************************************\n\nvar defaultPort = 8080;\n\n// *************************************************************************************************\n\nexports.run = function(argv) {\n    if (argv.pack) {\n        process.env.NODE_ENV = 'production';\n        process.env.APPJSPACK = true;\n    }\n\n    createServersFromConf(argv, function(err, servers) {\n        if (err || !servers.length) {\n            dandy.logException(\"No sites loaded.\");\n        } else {\n            if (argv.pack) {\n                var port = 8081;\n                var server = getPackServer(servers, argv.pack);\n                var httpServer = server.listen(port);\n\n                if (server.appVersion) {\n                    server.appVersion = incrementRepoVersion(server.appVersion);\n                } else {\n                    server.appVersion = 'v0.0';\n                }\n\n                console.log('Creating version', server.appVersion);\n\n                saveRepoVersion(server.repoPath, server.appVersion);\n                server.appjsApp.appVersion = server.appVersion;\n\n                packServer(server, port, function(err) {\n                    if (err) {\n                        console.log(err);\n                    } else {\n                        console.log('done.');\n                    }\n                    process.exit(0);\n                });\n            } else {\n                var port = argv.port || defaultPort;\n                var server = getMainServer(servers, argv);\n                server.listen(port);\n                console.log(\"App.js server listening on port %d (%s)\", server.address().port,\n                            new Date());\n            }\n        }       \n    });\n}\n\nexports.route = function(conf) {\n    var app = new App(conf);\n    return app.route(); \n}\n\nexports.App = App;\nexports.searchScript = pkg.searchScript;\nexports.searchStatic = pkg.searchStatic;\nexports.shortenStaticPath = pkg.shortenStaticPath;\n\n// *************************************************************************************************\n\nfunction createServersFromConf(argv, cb) {\n    var confs = readConf(argv);\n    async.map(confs, ibind(function(conf, cb2) {\n        createSiteServer(conf, argv, cb2);\n    }), cb);\n}\n\nfunction readConf(argv) {\n    if (argv._[0]) {\n        try {\n            var confPath = argv._[0];\n            var content = fs.readFileSync(confPath, 'utf8');\n            var confs = JSON.parse(content);\n            if (!(confs instanceof Array)) {\n                confs = [confs];\n            }\n            return confs;\n        } catch (exc) {\n            console.error(\"Unable to read conf at %s\", confPath);\n        }\n    } else {\n        return [argv];\n    }\n}\n\nfunction getMainServer(servers) {\n    if (servers.length == 1) {\n        return servers[0];\n    } else {\n        var hub = express.createServer();\n\n        servers.forEach(function(server) {\n            hub.use(express.vhost(server.host, server));\n            hub.use(express.vhost('*.' + server.host, server));\n        });\n        hub.use(hub.router);\n        hub.get(\"*\", function(req, res) {\n            res.send('Nothing to see here.', {'Content-Type': 'text/plain'}, 200);\n        });\n        return hub;\n    }   \n}\n\nfunction getPackServer(servers, host) {\n    for (var i = 0, l = servers.length; i < l; ++i) {\n        var server = servers[i];\n        if (server.host == host) {\n            return server;\n        }\n    }\n}\n\nfunction createSiteServer(conf, argv, cb) {\n    assert(conf.host, \"No host specified.\");\n    assert(conf.app, \"No app module specified.\");\n\n    var server = express.createServer();\n    server.conf = conf;\n\n    server.host = conf.host;\n    server.repoPath = fixPath(conf.repo); \n    server.appPath = fixPath(conf.app);\n    server.logsPath = fixPath(conf.logs);\n    server.cachesPath = fixPath(conf.caches);\n\n    if (server.repoPath) {\n        server.appVersion = loadRepoVersion(server.repoPath);\n    }\n\n    server.rewrite = _.bind(rewriter.rewrite, server);\n\n    server.configure(function() {\n        server.use(rewriter);\n        server.use(defaultMiddleware);\n        server.use(express.query());\n        server.use(express.bodyParser());\n        server.use(express.cookieParser());\n    \n        if (server.logsPath) {\n            server.use(logger({path: server.logsPath}));\n        }\n\n        server.use(server.router);\n    });\n\n    server.configure('development', function() {\n        server.use(express.errorHandler({ dumpExceptions: true, showStack: true })); \n    });\n\n    server.configure('production', function() {\n        server.use(express.errorHandler()); \n    });\n\n    if (server.cachesPath && !argv.disableCache) {\n        server.diskCache = new Cache(server.cachesPath, !!server.cachesPath, true, true);\n    }\n\n    var appPath = require.resolve(server.appPath);\n    pkg.findPackageInfo(appPath, abind(function(err, result) {\n        server.appName = result.info.name;\n        server.appPackage = result.info;\n\n        var app = require(server.appPath);\n        app(server, conf);\n\n        if (server.appjsApp) {\n            server.appjsApp.appVersion = server.appVersion;            \n        }\n\n        cb(0, server);\n    }, cb, this));\n           \n    // blog.configure(server);\n\n    // var middleware = options.disableCache ? null : [cacheware(blog.cache)];\n\n    // syndicate.route(server, blog, middleware);\n    // blog.api.route(server, middleware);\n    // appjs.route(server, blog.app, blog.api, blog.cache, options || {});\n}\n\nfunction defaultMiddleware(req, res, next) {\n    res.setHeader('Date', new Date()+'');\n    res.setHeader('Vary', 'Accept-Encoding');\n    res.setHeader('Server', 'App.js');\n    \n    res.sendSafely = utils.sendSafely;\n    next();    \n}\n\nfunction fixPath(thePath) {\n    return thePath ? thePath.replace(/^~/, process.env.HOME) : '';\n}\n\n// *************************************************************************************************\n\nfunction packServer(server, port, cb) {\n    var app = server.appjsApp;\n    var urlBase = 'http://localhost:' + port;\n    var urls = [\n        '/favicon.ico',\n        '/app.js/cache.manifest',\n        '/app.js/js',\n        '/app.js/css',\n    ];\n\n    var remaining = urls.length+1;\n    var urlMap = {\n        '/': '/index.html',\n    };\n    for (var i = 0, l = urls.length; i < l; ++i) {\n        var url = urls[i];\n        urlMap[url] = url;\n    }\n\n    var versionPath = path.join(server.repoPath, server.appVersion);\n    mkdirsSync(versionPath);\n\n    for (var urlPath in urlMap) {\n        var destPathFragment = urlMap[urlPath];\n        var destPath = path.join(versionPath, destPathFragment);\n        var url = urlBase + urlPath;\n        downloadFile(url, destPath, function(err) {\n            if (--remaining == 0) {\n                downloadStaticFiles(server, function(err) {\n                    cb(err);\n                });\n            }\n        });\n    }\n}\n\nfunction downloadStaticFiles(server, cb) {\n    var app = server.appjsApp;\n\n    pkg.searchStatic(app.packageName, app.paths, abind(function(err, staticPath) {\n        var destStaticPath = path.join(server.repoPath, server.appVersion, 'app.js', 'static',\n                                       app.packageName);\n        mkdirsSync(destStaticPath);\n        ncp(staticPath, destStaticPath, function(err) {\n            cb(err);\n        })\n    }, cb, this));\n}\n\nfunction downloadFile(url, destPath, cb) {\n    var chunks = [];\n    http.get(url, function(res) {\n        res.on('data', function (chunk) {\n            chunks[chunks.length] = chunk;\n        });\n        res.on('end', function () {\n            var data = chunks.join('');\n\n            var dirPath = path.dirname(destPath);\n            mkdirsSync(dirPath);\n\n            fs.writeFile(destPath, data, function(err) {\n                console.log('Downloaded', url, 'to', destPath);\n                cb(err);\n            });\n        });\n    }).on('error', function(e) {\n      cb(e);\n    });\n}\n\nfunction loadRepoVersion(repoPath) {\n    var versionPath = path.join(repoPath, 'version.json');\n    try {\n        var versionJson = fs.readFileSync(versionPath);\n        if (versionJson) {\n            return JSON.parse(versionJson).version;\n        }        \n    } catch (exc) {\n        return null;\n    }\n}\n\nfunction saveRepoVersion(repoPath, version) {\n    var versionPath = path.join(repoPath, 'version.json');\n    var json = JSON.stringify({version: version});\n    fs.writeFileSync(versionPath, json);\n}\n\nfunction incrementRepoVersion(version) {\n    var parts = version.split('.');\n    parts[parts.length-1] = parseInt(parts[parts.length-1]) + 1;\n    return parts.join('.');\n}\n","/home/travis/build/npmtest/node-npmtest-app.js/node_modules/app.js/lib/App.js":"\nvar path = require('path'),\n    fs = require('fs'),\n    url = require('url'),\n    _ = require('underscore'),\n    vm = require('vm'),\n    async = require('async'),\n    assert = require('assert').ok,\n    dandy = require('dandy/errors'),\n    abind = require('dandy/errors').abind,\n    ibind = require('dandy/errors').ibind,\n    Cache = require('diskcache').Cache,\n    cacheware = require('express-store'),\n    hascan = require('hascan'),\n    mime = require('mime'),\n    pkg = require('./pkg');\n    Renderer = require('./Renderer').Renderer;\n\n// *************************************************************************************************\n\nvar defaults = {\n    title: '',\n    client: null,\n    cdn: null,\n    repo: null,\n    api: null,\n    apiCache: null,\n    cache: null,\n    base: \"/\",\n    resources: \"app.js\",\n    language: 'en',\n    charset: 'utf8',\n    offline: false,\n    viewport: null,\n    rss: null,\n    appcache: null,\n    inlineContent: true,\n    stripFeatures: true,\n    webAppCapable: false,\n    statusBarStyle: null,\n    inlineImageMaxSize: 1000,\n    htmlHeader: '<!-- To view the original source of this page, add ?viewsource to the URL. -->',\n    jsHeader: '/* To view the original source of this page, add ?viewsource to the URL. */',\n    socket: null,\n    configs: {\n        development: {\n            loader: 'dynamic',\n            js: 'source',\n            css: 'source',\n            images: 'source',\n            icons: 'source',\n            content: 'source',\n        },\n        production: {\n            loader: 'static',\n            js: 'inline',\n            css: 'inline',\n            images: 'inline',\n            icons: 'source',\n            content: 'inline',\n        }\n    }\n};\n\nvar defaultMimeType = 'text/plain';\nvar htmlMimeType = 'text/html';\n\nvar reCrawlers = /googlebot|bingbot|slurp/i;\nvar reCDNs = /Amazon\\sCloudFront/i;\n\nvar reRootFiles = /(robots\\.txt)|(favicon\\.ico)|(apple-touch-icon(.*?)\\.png)/;\n\n// *************************************************************************************************\n\nfunction App(conf) {\n    this.paths = process.env.NODE_PATH ? process.env.NODE_PATH.split(';') : [];\n\n    this._assignConfig(conf);\n\n    if (this.repo) {\n        this.repo = this.repo.replace(/^~/, process.env.HOME);\n    }\n\n    this.base = addTrailingSlash(this.base);\n    this.baseLength = this.base.split(\"/\").length-2;\n    this.startupTime = new Date().getTime();\n\n    this.renderer = new Renderer(this, this.api, this.apiCache, this.base);\n\n    if (!this.cache) {\n        this.cache = new Cache(null, false, true, true);\n    }\n}\n\nexports.App = App;\n\nApp.prototype = {\n    get resourceBase() {\n        return this.base + this.resources;\n    },\n\n    get staticPath() {\n        return this.resourceBase + \"/static\";    \n    },\n\n    get jsPath() {\n        return this.resourceBase + \"/js\";    \n    },\n\n    get cssPath() {\n        return this.resourceBase + \"/css\";    \n    },\n\n    get hasPath() {\n        return this.resourceBase + \"/has\";    \n    },\n\n    get polyfillsPath() {\n        return this.resourceBase + \"/polyfills\";    \n    },\n\n    get repoPath() {\n        return path.join(this.repo, this.appVersion);\n    },\n\n    get appcachePath() {\n        return this.resourceBase + \"/cache.manifest\";    \n    },\n\n    get appjsPrefix() {\n        if (!this.reResourcePrefix) {\n            return this.reResourcePrefix = new RegExp(\"^\" + this.resources + \"(\\\\.\\\\d+)?(:.*?)?$\");\n        } else {\n            return this.reResourcePrefix;\n        }\n    },\n\n    route: function() {\n        function handler(req, res, next) {\n            var urlOptions = readOptions(req.query, this);\n            if (isCrawler(req)) {\n                urlOptions.content = 'inline';\n            }\n            urlOptions.userAgent = req.header('user-agent');\n\n            // Note that the URL matching is done in the prepware middleware function\n            this._loadURL(req.urlParsed, req.appjsParts, req.appjsMatch, this.renderer, urlOptions,\n            function(err, result) {\n                if (err) {\n                    dandy.logException(err);\n                    send(err, true);\n                } else {\n                    send(result);\n                }\n            });\n\n            function send(result, isError) {\n                if (result.dependencies) {\n                    res.dependencies = _.pluck(result.dependencies, 'path');\n                }\n\n                var mimeType = result.mimeType || (result.path\n                    ? mime.lookup(result.path) || defaultMimeType\n                    : htmlMimeType);\n\n                if (isTextMimeType(mimeType)) {\n                    mimeType += '; charset=UTF-8'\n                }\n\n                res.header('Content-Type', mimeType);\n\n                if (!isError) {\n                    var latestTime = findLatestMtime(result.dependencies || []);\n                    if (latestTime) {\n                        res.header('ETag', latestTime);\n                    }\n\n                    // if (result.permanent || isCDN(req)) {\n                    //     res.header('Cache-Control', 'public, max-age=31536000');\n                    // } else {\n                        res.header('Cache-Control', 'public, max-age=0');\n                    // }               \n                }\n\n                res.send(result.body, result.error || 200);\n            }\n        }\n\n        if (this.cache) {\n            this.cache.on('unmonitor', _.bind(function(URL) {\n                this.invalidate(URL);\n            }, this));\n        }\n\n        if (this.socket) {\n            this._listenToSocket();            \n        }\n        var cacheMiddleware = this.cache ? cacheware(this.cache) : noware;\n        return [prepware(this), uaware(this), cacheMiddleware, _.bind(handler, this)];\n    },\n\n    staticRoute: function() {\n        function handler(req, res, next) {\n            var filePath;\n            if (!req.appjsMatch) {\n                filePath = 'index.html';\n            } else {\n                filePath = req.appjsParts.slice(1).join('/');\n            }\n\n            filePath = path.join(this.repoPath, filePath);\n            fs.stat(filePath, abind(function(err, stat) {\n                var dependencies = [{path: filePath, mtime: stat.mtime.getTime()}];\n                fs.readFile(filePath, abind(function(err, source) {\n                    send.call(this, {path: filePath, body: source, error: err}, !!err);\n                }, next, this));                  \n            }, next, this));\n\n            function send(result, isError) {\n                var mimeType = result.mimeType || (result.path\n                    ? mime.lookup(result.path) || defaultMimeType\n                    : htmlMimeType);\n\n                if (isTextMimeType(mimeType)) {\n                    mimeType += '; charset=UTF-8'\n                }\n\n                res.header('Content-Type', mimeType);\n\n                if (!isError) {\n                    res.header('ETag', this.appVersion);\n\n                    // if (result.permanent || isCDN(req)) {\n                    //     res.header('Cache-Control', 'public, max-age=31536000');\n                    // } else {\n                        res.header('Cache-Control', 'public, max-age=0');\n                    // }               \n                }\n\n                res.send(result.body, result.error || 200);\n            }\n        }\n\n        if (this.cache) {\n            this.cache.on('unmonitor', _.bind(function(URL) {\n                this.invalidate(URL);\n            }, this));\n        }\n\n        var cacheMiddleware = this.cache ? cacheware(this.cache) : noware;\n        return [prepware(this), cacheMiddleware, _.bind(handler, this)];\n    },\n\n    loadURL: function(URL, renderer, options, cb) {\n        var req = parseAppjsURL(this, URL, {});\n        return this._loadURL(req.urlParsed, req.appjsParts, req.appjsMatch, renderer, options, cb)\n    },\n\n    loadResources: function(req, cb) {\n        var options = readOptions(req, this);\n        this._prepare(abind(function(err) {\n            this.renderer.renderResources(options, cb);            \n        }, cb, this));\n    },\n\n    _loadURL: function(urlParsed, parts, m, renderer, options, cb) {\n        if (m) {\n            if (parts.length == 2) {\n                this._loadAppjs(renderer, options, cb);\n            } else {\n                if (parts[2] == 'static') {\n                    this._loadStatic(parts.slice(3).join('/'), renderer, options, cb);\n                } else if (parts[2] == 'js') {\n                    var userAgent = m[2] ? unescape(m[2].substr(1)) : '';\n                    if (userAgent) {\n                        options.userAgent = userAgent;\n                    }\n\n                    if (parts.length > 3) {\n                        options.js = 'source';\n                        options.css = 'included';\n                    }\n                    this._loadJS(parts.slice(3).join('/'), renderer, options, cb);\n                } else if (parts[2] == 'css') {\n                    this._loadCSS(renderer, options, cb);\n                } else if (parts[2] == 'cache.manifest') {\n                    this._loadAppcache(renderer, options, cb);\n                } else if (parts[2] == 'has') {\n                    this._loadHas(renderer, options, cb);\n                } else if (parts[2] == 'polyfills') {\n                    this._loadPolyfills(renderer, options, cb);\n                } else {\n                    cb(\"Not found\");\n                }\n            }\n        } else if (reRootFiles.exec(parts[1])) {\n            var newURL = this.staticPath + '/' + this.packageName + '/' + parts[1];\n            this.loadURL(newURL, renderer, options, cb);\n        } else {\n            this._loadPage(urlParsed, renderer, options, cb);\n        }\n    },\n\n    getContentScript: function(renderer, cb) {\n        if (!this.contentScript) {\n            this.loadURL(this.jsPath, renderer, {loader: 'static', js: 'inline', beautify: true},\n            abind(function(err, js) {\n                this.contentScript = vm.createScript(js.body, 'document.js');\n                cb(0, this.contentScript);\n            }, cb, this));\n        } else {\n            cb(0, this.contentScript);\n        }\n    },\n\n    invalidate: function(dependentURL) {\n        delete this.contentScript;\n        delete this.featureDB;\n        delete this.dependencies;\n\n        if (this.socketServer) {\n            this.socketServer.broadcast(JSON.stringify({\n                name: 'invalidate',\n                URL: this.normalizeURL(dependentURL.url)\n            }));\n        }\n    },\n\n    reloadPage: function() {\n        if (this.socketServer) {\n            this.socketServer.broadcast(JSON.stringify({\n                name: 'reload'\n            }));\n        }\n    },\n\n    normalizeURL: function(URL, category, timestamp) {\n        return this.renderer.renderURL(URL, category, true, timestamp);\n    },\n\n    // ---------------------------------------------------------------------------------------------\n\n    _assignConfig: function(conf) {\n        for (var name in defaults) {\n            if (name == \"configs\") {\n                var branch = process.env.NODE_ENV == \"production\"\n                             ? defaults.configs.production\n                             : defaults.configs.development;\n                for (var name in branch) {\n                    this[name] = name in conf ? conf[name] : branch[name];\n                }\n            } else {\n                this[name] = name in conf ? conf[name] : defaults[name];\n            }\n        }        \n    },\n\n    _loadPage: function(URL, renderer, options, cb) {\n        renderer.renderPage(URL, options, abind(function(err, result) {\n            cb(0, {\n                body: result.source,\n                permanent: options.js == \"inline\" && options.css == \"inline\",\n                dependencies: result.dependencies,\n            });\n        }, cb));        \n    },\n\n    _loadStatic: function(staticPath, renderer, options, cb) {\n        pkg.searchStatic(staticPath, this.paths, abind(function(err, filePath) {\n            if (filePath) {\n                fs.stat(filePath, abind(function(err, stat) {\n                    var dependencies = [{path: filePath, mtime: stat.mtime.getTime()}];\n                    fs.readFile(filePath, abind(function(err, source) {\n                        if (mime.lookup(filePath) == 'text/css') {\n                            renderer.compressCSS(source+'', staticPath, options,\n                            function(err, source) {\n                                cb(0, {path: filePath, body: source, dependencies: dependencies});\n                            });\n                        } else {\n                            cb(0, {path: filePath, body: source, raw: true,\n                                   dependencies: dependencies});\n                        }\n                    }, cb, this));                  \n                }, cb, this));\n            }\n        }, cb, this));\n    },\n\n    _loadJS: function(modulePath, renderer, options, cb) {\n        var scriptPath = this._cleanJSPath(modulePath, renderer);\n        var basePath = scriptPath == this.client ? null : this.client;\n\n        var searchPaths = [basePath];\n        if (this.paths.length) {\n            searchPaths.push.apply(searchPaths, this.paths);\n        }\n\n        pkg.searchScript(scriptPath, searchPaths, abind(function(err, findings) {\n            if (findings) {\n                renderer.renderScript(findings.path, findings.name, options, true,\n                    abind(function(err, result) {\n                        cb(0, {path: findings.path, name: findings.name, body: result.source,\n                               dependencies: result.dependencies, permanent: true});\n                    }, cb)\n                );\n            }\n        }, cb, this));\n    },\n\n    _loadAppjs: function(renderer, options, cb) {\n        var scriptName;\n        if (options.loader == \"static\" || options.js == \"worker\") {\n            scriptName = \"appjs-static.js\";\n        } else if (options.loader == \"dynamic\") {\n            scriptName = \"appjs-dynamic.js\";            \n        } else if (options.loader == \"standalone\") {\n            scriptName = \"appjs-standalone.js\";            \n        }\n        if (scriptName) {\n            var appjsPath = path.resolve(__dirname, '..', 'client', scriptName);\n            renderer.renderScriptRaw(appjsPath, '', options,\n                abind(function(err, result) {\n                    cb(0, {path: appjsPath, body: result.source, dependencies: result.dependencies});\n                }, cb)\n            );\n        } else {\n            cb(new Error(\"Loader unspecified\"));\n        }\n    },\n\n    _loadHas: function(renderer, options, cb) {\n        renderer.renderHas(options, abind(function(err, result) {\n            cb(0, {path: result.path, body: result.source, dependencies: result.dependencies});\n        }, cb));\n    },\n\n    _loadPolyfills: function(renderer, options, cb) {\n        renderer.renderPolyfills(options, abind(function(err, result) {\n            cb(0, {path: result.path, body: result.source, dependencies: result.dependencies});\n        }, cb));\n    },\n\n    _loadCSS: function(renderer, options, cb) {\n        renderer.renderStylesheet(options,\n            abind(function(err, result) {\n                cb(0, {path: result.path, body: result.source, dependencies: result.dependencies,\n                       permanent: true});\n            }, cb)\n        );\n    },\n\n    _loadAppcache: function(renderer, options, cb) {\n        renderer.renderAppcache(options,\n            abind(function(err, result) {\n                cb(0, {\n                    body: result.source,\n                    mimeType: 'text/cache-manifest',\n                    permanent: options.js == \"inline\" && options.css == \"inline\"\n                });\n            }, cb)\n        );\n    },\n\n    _prepare: function(cb) {\n        if (!this.dependencies) {\n            var searchPaths = this.paths;\n            pkg.traceScript(this.client, this.paths, false, abind(function(err, deps) {\n                this.dependencies = deps;\n\n                async.parallel([\n                    ibind(function(next) {\n                        hascan.getFeatureDB(_.keys(deps.has), abind(function(err, featureDB) {\n                            this.featureDB = featureDB;\n                            next(0);\n                        }, next, this));                        \n                    }, cb, this),\n\n                    ibind(function(next) {\n                        if (!this.packageName) {\n                            pkg.searchScript(this.client, searchPaths, abind(function(err, findings) {\n                                pkg.findPackageInfo(findings.path, abind(function(err, result) {\n                                    this.packageName = result.info.name;\n                                    next(0);\n                                }, cb, this));\n                            }, cb, this));\n                        } else {\n                            next(0);\n                        }\n                    }, cb, this),\n\n                    ibind(function(next) {\n                        if (!this.polyfills) {\n                            var polyfillsDirPath = path.join(__dirname, '..', 'client', 'polyfills');\n                            this.polyfills = {};\n                            fs.readdir(polyfillsDirPath, abind(function(err, names) {\n                                if (!err) {\n                                    _.each(names, ibind(function(name) {\n                                        var feature = path.basename(name, '.js');\n                                        this.polyfills[feature] = true;\n                                    }, cb, this));\n                                }\n                                next(0, deps);\n                            }, cb, this));\n                        } else {\n                            next(0);\n                        }\n                    }, cb, this),\n                ], abind(function(err, results) {\n                    cb(0, deps);\n                }, cb, this));\n            }, cb, this));\n        } else {\n            cb(0, this.dependencies);\n        }        \n    },\n\n    _cleanJSPath: function(jsPath, renderer) {\n        return jsPath\n            ? path.join(path.dirname(jsPath), path.basename(jsPath, '.js'))\n            : this.client;        \n    },\n\n    _listenToSocket: function() {\n        var u = url.parse('ws://' + this.socket);\n        var ws = require(\"websocket-server\");\n        this.socketServer = ws.createServer();\n        this.socketServer.listen(u.port);\n    }\n};\n\n// *************************************************************************************************\n\nfunction parseAppjsURL(app, URL, ret) {\n    var u = ret.urlParsed = url.parse(URL);\n\n    // Remove the : symbol used to append a timestamp purely for caching purposes\n    var timestampIndex = u.pathname.lastIndexOf(':');\n    if (timestampIndex >= 0) {\n        u.pathname = u.pathname.substr(0, timestampIndex);\n    }\n\n    var parts = ret.appjsParts = u.pathname.split('/').slice(app.baseLength);\n    ret.appjsMatch = app.appjsPrefix.exec(parts[1]);\n    return ret;\n}\n\nfunction prepware(app) {\n    return function(req, res, next) {\n        parseAppjsURL(app, req.url, req);\n\n        app._prepare(function(err, deps) {\n            if (err) {\n                console.error(err.stack || err);\n            } else {\n                next();\n            }\n        });\n    }\n}\n\n/**\n * Switches to content=inline if user agent is unknown or if no polyfills available for its\n * missing features.\n */\nfunction uaware(app) {\n    return function(req, res, next) {\n        if (!req.appjsMatch && app.inlineContent) {\n            var featureMap = app.featureDB.getFeatureMap(req.header('user-agent'), true);\n            if (!featureMap) {\n                forceContentInline();\n            } else {\n                for (var name in featureMap) {\n                    var isRequired = app.dependencies.has[name];\n                    if (isRequired && !featureMap[name] && !app.polyfills[name]) {\n                        forceContentInline();\n                        break;\n                    }\n                }\n            }\n        }\n\n        function forceContentInline() {\n            var U = url.parse(req.url, true);\n            U.query['content'] = 'inline';\n            req.url = url.format(U);\n            req.query = U.query;\n        }\n        next();    \n    }\n}\n\nfunction noware(req, res, next) {\n    next();\n}\n\nfunction readOptions(query, defaults) {\n    var viewSource = 'viewsource' in query;\n    return {\n        loader: (viewSource ? 'dynamic' : 'loader' in query ? query.loader : defaults.loader),\n        js: (viewSource ? 'source' : 'js' in query ? query.js : defaults.js),\n        css: (viewSource ? 'source' : 'css' in query ? query.css : defaults.css),\n        images: (viewSource ? 'source' : 'images' in query ? query.images : defaults.images),\n        content: (viewSource ? 'source' : 'content' in query ? query.content : defaults.content),\n        icons: (viewSource ? 'source' : 'icons' in query ? query.icons : defaults.icons),\n    };\n}\n\nfunction findLatestMtime(deps) {\n    var maxTime = 0;\n    _.each(deps, function(dep) {\n        if (dep.mtime > maxTime) {\n            maxTime = dep.mtime;\n        }\n    });\n    return maxTime;\n}\n\nfunction isCrawler(req) {\n    var userAgent = req.headers['user-agent'];\n    return !!reCrawlers.exec(userAgent);\n}\n\nfunction isCDN(req) {\n    var userAgent = req.headers['user-agent'];\n    return !!reCDNs.exec(userAgent);\n}\n\nfunction isTextMimeType(mimeType) {\n    return mimeType.indexOf('text/') == 0\n        || mimeType == 'application/json'\n        || mimeType == 'application/javascript'\n        || mimeType == 'application/x-javascript';\n}\n\nfunction addTrailingSlash(s) {\n    if (s && s.substr(s.length-1) == '/') {\n        return s;\n    } else {\n        return s + '/';\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-app.js/node_modules/app.js/lib/pkg.js":"\nvar fs = require('fs'),\n    path = require('path'),\n    abind = require('dandy/errors').abind,\n    _ = require('underscore'),\n    hascan = require('hascan');\n    \n// *************************************************************************************************\n\n// XXXjoe Need a public way to add file extensions to this list\nvar transientExtensions = [];\nvar packageCache = {};\n\nvar reRequire = /require\\s*\\(\\s*[\"'](.*?)[\"']\\s*\\)/g;\nvar reStyle = /^\\s*\"style\\s+(.*?)\\s*\"\\s*;?\\s*$/gm;\nvar rePragma = /^\\s*\"pragma\\s+(.*?)\\s*\"\\s*;?\\s*$/gm;\n\nvar reCSSImport = /@import\\s+(url\\s*\\()?\"(.*?)\"\\)?/g;\nvar reCSSURL = /url\\(\"?(.*?)\"?\\)/g;\nvar reIconFiles = /(favicon\\.ico)|(apple-touch-icon(.*?)\\.png)/;\n\n// *************************************************************************************************\n\nexports.searchScript = function(modulePath, searchPaths, cb) {\n    if (typeof(searchPaths) == 'function') { cb = searchPaths; searchPaths = null; }\n\n    if (!(searchPaths instanceof Array)) {\n        searchPaths = [searchPaths];\n    } else {\n        searchPaths = searchPaths.slice();\n        searchPaths.push(null);\n    }\n\n    if (process.env.NODE_PATH) {\n        searchPaths.push.apply(searchPaths, process.env.NODE_PATH.split(';'));\n    }\n\n    if (modulePath[0] == '/') {\n        complete(modulePath);\n    } else {\n        searchBasePath(searchPaths.shift());\n    }\n\n    function searchBasePath(basePath) {\n        var baseScriptPath;\n        if (basePath) {\n            try {\n                baseScriptPath = path.dirname(require.resolve(basePath));\n            } catch (exc) {\n                baseScriptPath = basePath;\n            }\n        }\n        if (baseScriptPath) {\n            var absolutePath = path.resolve(baseScriptPath, modulePath);\n            try {\n                var scriptPath = require.resolve(absolutePath);\n                return complete(scriptPath);\n            } catch (exc) {\n\n            }\n        }\n\n        if (baseScriptPath) {\n            var baseDir = baseScriptPath;\n            findInNodeModules(baseDir);\n        } else {\n            complete(modulePath);\n        }        \n    }\n\n    /**\n     * require.resolve unfortunately can't be given a relative base path, so we have\n     * to simulate its behavior ourself.  This here does the node_modules search.\n     */\n    function findInNodeModules(containerPath) {\n        fs.stat(containerPath, abind(function(err, stat) {\n            if (stat.isDirectory()) {\n                var foundPath = path.resolve(containerPath, 'node_modules', modulePath);\n                try {\n                    foundPath = require.resolve(foundPath);\n                    complete(foundPath);\n                } catch (exc) {\n                    if (containerPath != '/') {\n                        findInNodeModules(path.dirname(containerPath));\n                    } else {\n                        tryNext();\n                    }\n                }\n            } else {\n                tryNext();\n            }\n        }, fail, this));\n    }\n\n    function complete(foundPath) {\n        try {\n            var scriptPath = require.resolve(foundPath);\n            exports.shortenModulePath(scriptPath, abind(function(err, shortModulePath) {\n                cb(0, {path: scriptPath, name: shortModulePath});\n            }, fail, this));            \n        } catch (exc) {\n            fail();\n        }\n    }\n\n    function tryNext() {\n        if (!searchPaths.length) {\n            fail();\n        } else {\n            var nextPath = searchPaths.shift();\n            searchBasePath(nextPath);\n        }\n    }\n\n    function fail() {\n        cb(new Error(\"Module '\" + modulePath + \"' not found.\"));\n    }\n}\n\nexports.searchStatic = function(modulePath, searchPaths, isURL, cb) {\n    if (typeof(isURL) == 'function') { cb = isURL; isURL = false; }\n    if (typeof(searchPaths) == 'function') { cb = searchPaths; searchPaths = null; }\n\n    modulePath = securePath(modulePath);\n    if (!modulePath) { cb(\"Illegal path\"); return; }\n\n    findBasePath(abind(function(err, basePath) {\n        try {            \n            var parts = modulePath.split('/');\n            if (!parts.length) {\n                cb(0, '');\n            }\n\n            exports.findPackageStaticPath(basePath, abind(function(err, staticPath) {\n                var filePath = path.join(staticPath, parts.slice(1).join('/'));\n                cb(0, filePath);\n            }, cb, this));\n        } catch (exc) {\n            console.error(exc.stack)\n            cb(exc);\n        }\n    }, cb, this));\n\n    function findBasePath(cb) {\n        if (modulePath[0] == '.') {\n            cb(0, searchPaths[0]);\n        } else {\n            var baseModule = modulePath.split('/')[0];\n            exports.searchScript(baseModule, searchPaths, abind(function(err, findings) {\n                if (isURL) {\n                    cb(0, findings.path);\n                } else {\n                    cb(0, findings.path);\n                }\n            }, cb, this));\n        }\n    }\n}\n\nexports.traceStylesheets = function(rootModuleName, searchPaths, cb) {\n    var styleMap = {};\n    var depth = 0;\n\n    traceScript.apply(this, [rootModuleName]);\n\n    function traceScript(modulePath, basePath, sourceLine) {\n        ++depth;\n\n        exports.searchScript(modulePath, basePath, tbind(function(err, findings) {\n            fs.stat(findings.path, tbind(function(err, stat) {\n                fs.readFile(findings.path, tbind(function(err, source) {\n                    var m;\n                    while (m = reStyle.exec(source)) {\n                        var stylesheetPath = exports.normalizeName(m[1], findings.name);\n                        traceStylesheet.apply(this, [stylesheetPath, m[0]]);\n                    }\n\n                    complete();\n                }, this));\n            }, this));\n        }, this));\n    }\n\n    function traceStylesheet(stylesheetPath, sourceLine) {\n        if (!(stylesheetPath in styleMap)) {\n            ++depth;\n\n            exports.traceStylesheet(stylesheetPath, searchPaths, true, null, sourceLine,\n            tbind(function(err, res) {\n                _.extend(styleMap, res.css);\n\n                complete();\n            }, this));\n        }\n    }\n\n    function tbind(fn, self) {\n        return function(err, obj) {\n            if (err) {\n                if (!--depth) {\n                    cb(0, styleMap);\n                }\n            } else {\n                try {\n                    fn.apply(self, [0, obj]);\n                } catch (exc) {\n                    cb(exc);\n                }\n            }\n        }\n    }\n\n    function complete() {\n        if (!--depth) {\n            cb(0, styleMap);\n        }\n    }\n};\n\nexports.traceScript = function(rootModuleName, searchPaths, skipDebug, cb) {\n    var moduleMap = {};\n    var styleMap = {};\n    var iconMap = {};\n    var imageMap = {};\n    // XXXjoe array-indexof is used in appjs.js, so I should just trace appjs.js too!\n    var hasMap = {\"array-indexof\": true};\n    var results = {js: moduleMap, css: styleMap, icons: iconMap, images: imageMap, has: hasMap};\n    var depth = 0;\n    var queue = [];\n\n\n    enqueue(traceIcons, [rootModuleName]);\n    enqueue(traceScript, [rootModuleName]);\n\n    next();\n\n    function traceScript(modulePath, basePath, sourceLine) {\n        ++depth;\n\n        var localPaths = searchPaths ? searchPaths.slice() : [];\n        localPaths.push(basePath);\n        exports.searchScript(modulePath, localPaths, tbind(function(err, findings) {\n            if (findings.name in moduleMap) {\n                next();\n            } else {\n                fs.stat(findings.path, tbind(function(err, stat) {\n                    fs.readFile(findings.path, tbind(function(err, source) {\n                        var pragmas = moduleMap[findings.name] = {\n                            debug: !shouldTrace(modulePath),\n                            path: findings.path,\n                            source: source+'',\n                            sourceLine: sourceLine,\n                            mtime: stat.mtime.getTime()\n                        };\n\n                        var m;\n                        while ((m = rePragma.exec(source))) {\n                            pragmas[m[1]] = 1;\n                        }\n                        _.each(hascan.findFeatureTests(source+''), function(required, feature) {\n                            hasMap[feature] = required;\n                        });\n\n                        if (!skipDebug || !pragmas.debug) {\n                            while(m = reRequire.exec(source)) {\n                                var depName = m[1];\n                                enqueue(traceScript, [depName, findings.name, m[0]]);\n                            }\n                        }\n\n                        while (m = reStyle.exec(source)) {\n                            var stylesheetPath = exports.normalizeName(m[1], findings.name);\n                            enqueue(traceStylesheet, [stylesheetPath, m[0]]);\n                        }\n\n                        next();\n                    }, this));\n                }, this));\n            }\n        }, this));\n    }\n\n    function traceStylesheet(stylesheetPath, sourceLine) {\n        if (!(stylesheetPath in styleMap)) {\n            ++depth;\n\n            var localPaths = searchPaths ? searchPaths.slice() : [];\n            // localPaths.push(basePath);\n\n            exports.traceStylesheet(stylesheetPath, localPaths, true, null, sourceLine,\n            tbind(function(err, res) {\n                _.extend(results.css, res.css);\n                _.extend(results.images, res.images);\n\n                next();\n            }, this));\n        }\n    }\n\n    function traceIcons(modulePath, basePath) {\n        ++depth;\n\n        var localPaths = searchPaths ? searchPaths.slice() : [];\n        localPaths.push(basePath);\n\n        exports.searchScript(modulePath, localPaths, tbind(function(err, findings) {\n            exports.findPackageStaticPath(findings.path, tbind(function(err, staticPath) {\n                fs.readdir(staticPath, tbind(function(err, paths) {\n                    _.each(paths, function(fileName) {\n                        var m = reIconFiles.exec(fileName);\n                        if (m) {\n                            var filePath = path.join(staticPath, fileName);\n                            fs.stat(filePath, function(err, stat) {\n                                if (!err) {\n                                    iconMap[fileName] = {path: filePath, mtime: stat.mtime.getTime()};\n                                }\n                            });\n                        }\n                    }, this);\n\n                    next();\n                }));\n            }, this));\n        }, this));\n    }\n\n    function enqueue(fn, args) {\n        queue.push(function() { fn.apply(this, args)});\n    }\n\n    function next() {\n        if (queue.length) {\n            var fn = queue.shift();\n            fn();\n        } else {\n            cb(0, results);\n        }\n    }\n    function tbind(fn, self) {\n        return function(err, obj) {\n            if (err) {\n                next();\n            } else {\n                try {\n                    fn.apply(self, [0, obj]);\n                } catch (exc) {\n                    next();\n                }\n            }\n        }\n    }\n},\n\nexports.traceStylesheet = function(modulePath, searchPaths, recursive, source, sourceLine, cb) {\n    var styleMap = {};\n    var imageMap = {};\n    var results = {css: styleMap, images: imageMap};\n    var depth = 0;\n\n    if (recursive) {\n        traceStylesheet.apply(this, [modulePath, sourceLine]);\n    } else {\n        scanSource.apply(this, [source, path.dirname(modulePath)]);\n    }\n\n    function scanSource(source, basePath) {\n        ++depth;\n\n        var m;\n        while ((m = reCSSImport.exec(source)) && m[2]) {\n            var stylesheetPath = exports.normalizeName(m[2], basePath, true);\n            traceStylesheet.apply(this, [stylesheetPath, m[1], m[0]]);\n        }\n\n        while ((m = reCSSURL.exec(source)) && m[1]) {\n            var imagePath = exports.normalizeName(m[1], basePath, true);\n            traceImage.apply(this, [imagePath, m[1], m[0]]);\n        }\n\n        if (!--depth) {\n            cb(0, results);\n        }\n    }\n\n    function traceStylesheet(stylesheetPath, sourceURL, sourceLine) {\n        if (!(stylesheetPath in styleMap)) {\n            ++depth;\n\n            exports.searchStatic(stylesheetPath, searchPaths, false, _.bind(function(err, stylesheetPath) {\n                if (err) { if (!--depth) cb(0, results); return; }\n                fs.stat(stylesheetPath, _.bind(function(err, stat) {\n                    if (err) { if (!--depth) cb(0, results); return; }\n\n                    fs.readFile(stylesheetPath, _.bind(function(err, source) {\n                        if (err) { if (!--depth) cb(0, results); return; }\n\n                        exports.shortenStaticPath(stylesheetPath, _.bind(function(err, absolutePath) {\n                            if (err) { if (!--depth) cb(0, results); return; }\n\n                            styleMap[absolutePath] = {\n                                path: stylesheetPath,\n                                sourceURL: sourceURL,\n                                sourceLine: sourceLine,\n                                mtime: stat.mtime.getTime()\n                            };\n\n                            if (recursive) {\n                                scanSource.apply(this, [source, path.dirname(absolutePath), true]);\n                            }\n\n                            if (!--depth) {\n                                cb(0, results);\n                            }\n                        }, this));\n                    }, this));\n                }, this));          \n            }, this));          \n        }\n    }\n\n    function traceImage(modulePath, sourceURL, sourceLine) {\n        if (!(modulePath in styleMap)) {\n            ++depth;\n\n            exports.searchStatic(modulePath, searchPaths, true, _.bind(function(err, imagePath) {\n                if (err) { if (!--depth) cb(0, results); return; }\n\n                fs.stat(imagePath, _.bind(function(err, stat) {\n                    if (err) { if (!--depth) cb(0, results); return; }\n\n                    imageMap[modulePath] = {\n                        path: imagePath,\n                        sourceURL: sourceURL,\n                        sourceLine: sourceLine,\n                        mtime: stat.mtime.getTime()\n                    };\n\n                    if (!--depth) {\n                        cb(0, results);\n                    }\n                }, this));          \n            }, this));          \n        }           \n    }\n},\n\nexports.findPackagePath = function(scriptPath, cb) {\n    var dirName = path.dirname(scriptPath);\n    checkForPackage(dirName);\n\n    function checkForPackage(dirName) {\n        if (!dirName) { cb(\"Not found\"); return; }\n\n        var packagePath = path.join(dirName, \"package.json\");\n        fs.stat(packagePath, function(err, stat) {\n            if (err || !stat.isFile()) {\n                // Keep searching upwards until we find directory containing package.json\n                var nextPath = path.dirname(dirName);\n                if (nextPath != dirName) {\n                    checkForPackage(nextPath);\n                } else {\n                    cb(\"Not found\");\n                }\n            } else {\n                cb(0, packagePath);\n            }\n        });\n    }\n}\n\nexports.findPackageStaticPath = function(scriptPath, cb) {\n    exports.findPackageInfo(scriptPath, abind(function(err, result) {\n        var staticPath = readStaticPath(result);\n        if (staticPath) {\n            cb(0, staticPath);          \n        } else {\n            cb(\"No static path for \" + scriptPath);\n        }\n    }, cb, this));\n}\n\nexports.findPackageInfo = function(scriptPath, cb) {\n    if (scriptPath in packageCache) {\n        return cb(0, packageCache[scriptPath]);\n    }\n    exports.findPackagePath(scriptPath, abind(function(err, packagePath) {\n        fs.readFile(packagePath, abind(function(err, packageJSON) {\n            var packageInfo = JSON.parse(packageJSON);\n            var payload = {path: packagePath, info: packageInfo};\n            packageCache[scriptPath] = payload;\n            cb(0, payload);\n        }, cb));\n    }, cb));\n}\n\nexports.shortenModulePath = function(scriptPath, cb) {\n    exports.findPackageInfo(scriptPath, abind(function(err, result) {\n        // Read the package.json so we can use info contained within\n        var dirName = path.dirname(result.path);\n        var mainPath = path.resolve(dirName, result.info.main||'');\n        if (path.extname(mainPath) != '.js') {\n            mainPath += '.js';\n        }\n        if (mainPath == scriptPath) {\n            // If it's the main script, shorten it to the package name\n            cb(0, result.info.name);\n        } else {\n            // Remove the directories above the package directory\n            var relativePath = scriptPath.substr(dirName.length+1);\n            var relativeName = path.join(result.info.name, relativePath);\n\n            // Remove .js extension if there is one\n            var ext = path.extname(relativeName);\n            if (ext == '.js') {\n                relativeName = path.join(path.dirname(relativeName),\n                                         path.basename(relativeName, ext));\n            }\n            cb(0, relativeName);\n        }\n    }, cb));\n}\n\nexports.shortenStaticPath = function(resourcePath, cb) {\n    exports.findPackageInfo(resourcePath, abind(function(err, result) {\n        var staticPath = readStaticPath(result);\n        if (staticPath) {\n            // Remove the directories above the package directory\n            var relativePath = resourcePath.substr(staticPath.length+1);\n            var relativeName = path.join(result.info.name, relativePath);\n            cb(0, relativeName);\n        } else {\n            cb(0, null);\n        }\n    }, cb, this));\n}\n\nexports.normalizeName = function(name, baseName, isURL) {\n    if (isURL) {\n        if (!baseName || (name && name[0] == '/')) {\n            return name;\n        } else {\n            return path.join(baseName, name);\n        }\n    } else {\n        if (baseName && name && name[0] == '.') {\n            // Relative paths inside of root modules are contained within the module, not its parent\n            if (baseName.indexOf('/') == -1) {\n                baseName += '/';\n            }\n            return path.normalize(path.join(baseName, name));\n        } else {\n            return name;\n        }\n    }\n}\n\n// *************************************************************************************************\n\nfunction readStaticPath(result) {\n    var appInfo = result.info['app.js'];\n    if (appInfo && appInfo['static']) {\n        return path.resolve(path.dirname(result.path), appInfo['static']);\n    }\n}\n\nfunction securePath(insecurePath) {\n    var parts = insecurePath.split('/');\n    // Upwards paths are illegal\n    if (parts.indexOf('..') != -1 ) {\n        return '';      \n    } else {\n        return insecurePath;\n    }\n}\n\nfunction shouldTrace(name) {\n    return !(path.extname(name) in transientExtensions);\n}    ","/home/travis/build/npmtest/node-npmtest-app.js/node_modules/app.js/lib/Renderer.js":"var path = require('path'),\n    fs = require('fs'),\n    url = require('url'),\n    _ = require('underscore'),\n    async = require('async'),\n    jsdom = require('jsdom').jsdom,\n    domToHtml = require('jsdom/lib/jsdom/browser/domtohtml').domToHtml,\n    cssmin = require('cssmin'),\n    mime = require('mime'),\n    abind = require('dandy/errors').abind,\n    ibind = require('dandy/errors').ibind,\n    transformjs = require('transformjs'),\n    hascan = require('hascan'),\n    pkg = require('./pkg');\n\n// *************************************************************************************************\n\nconst docType = '<!DOCTYPE html>';\nconst defaultHost = '127.0.0.1';\nconst defaultPort = 8080;\n\nconst loadTimeout = 30000;\n\nvar reRequire = /require\\s*\\(\\s*[\"'](.*?)[\"']\\s*\\)/g;\nvar reCSSURL = /url\\(\"?(.*?)\"?\\)/g;\n\n// *************************************************************************************************\n\nexports.Renderer = function(app, api, apiCache, baseURLPath) {\n    this.app = app;\n    this.api = api;\n    this.apiCache = apiCache;\n    this.baseURLPath = addTrailingSlash(baseURLPath);\n    this.builtinScripts = [app.resourceBase];\n}\n\nexports.Renderer.prototype = {\n    renderResources: function(options, cb) {\n        this._renderResources({}, options, cb);\n    },\n\n    renderPage: function(URL, options, cb) {\n        this._renderPage({}, options, abind(function(err, html) {\n            this.renderContent(URL, html, options, abind(function(err, html) {\n                cb(0, {source: html, dependencies: this.app.dependencies.js});\n            }, cb, this));\n        }, cb, this));\n    },\n\n    renderHas: function(options, cb) {\n        var deps = this.app.dependencies;\n        hascan.buildHasWithTests(_.keys(deps.has), abind(function(err, source) {\n            cb(0, {path: 'has.js', source: source, dependencies: _.values(deps.js)});\n        }, cb, this))\n    },\n\n    renderPolyfills: function(options, cb) {\n        var deps = [];\n        var features = this.app.dependencies ? _.keys(this.app.dependencies.has) : [];\n\n        async.map(features,\n            _.bind(function(feature, cb2) {\n                var featureMap = options.userAgent\n                                 ? this.app.featureDB.getFeatureMap(options.userAgent, true)\n                                 : {};\n                if (featureMap && !featureMap[feature]) {\n                    var polyfillPath = path.join(__dirname, '..', 'client', 'polyfills', feature+'.js');\n                    fs.lstat(polyfillPath, function(err, stat) {\n                        if (!err && stat.isFile()) {\n                            deps.push[{path: polyfillPath, mtime: stat.mtime.getTime()}];\n                            fs.readFile(polyfillPath, 'utf8', abind(function(err, data) {\n                                 cb2(0, data+'');\n                            }, cb, this))\n                        } else {\n                            cb2(0, '');\n                        }\n                    });\n                } else {\n                    cb2(0, '');\n                }\n            }, this),\n            abind(function(err, polyfills) {\n                var source = polyfills.join('');\n                cb(0, {path: 'polyfills.js', source: source, dependencies: _.values(deps.js)});\n            }, cb, this)\n        );\n    },\n\n    renderScript: function(scriptPath, modulePath, options, relink, cb) {\n        if ((options.js == \"inline\" || options.js == \"standalone\" || options.js == \"worker\") && relink) {\n            return this.renderScriptInline(scriptPath, modulePath, options, cb);\n        } else if (relink) {\n            return this.renderScriptDebug(scriptPath, modulePath, options, cb);\n        } else {\n            return this.renderScriptRaw(scriptPath, modulePath, options, cb);            \n        }\n    },\n\n    renderScriptRaw: function(scriptPath, modulePath, options, cb) {\n        fs.stat(scriptPath, abind(function(err, stat) {\n            var deps = [{path: scriptPath, mtime: stat.mtime.getTime()}];\n            fs.readFile(scriptPath, 'utf8', abind(function(err, data) {\n                var source = data+'';\n                cb(0, {path: 'all.js', source: source, dependencies: deps});\n            }, cb, this));            \n        }, cb, this));\n    },\n\n    renderScriptDebug: function(scriptPath, modulePath, options, cb) {\n        var deps = [];\n        async.parallel([\n            ibind(function(next) {\n                if (options.css == \"included\") {\n                    return next(0, ''); // XXXjoe Temporary\n                    \n                    pkg.traceStylesheets(scriptPath, this.app.paths, abind(function(err, cssMap) {\n                        var sections = _.map(cssMap, _.bind(function(dep, urlPath) {\n                            deps.push(dep);\n\n                            var stylesheetPath = this.app.staticPath + '/' + urlPath;\n                            var stylesheetURL = this.renderURL(stylesheetPath, 'css');\n                            return 'require.stylesheet(\"' + stylesheetURL + '\");';\n                        }, this));\n                        next(0, sections.join('\\n'));\n                    }, next, this));\n                } else {\n                    next(0, '');\n                }\n            }, cb, this),\n            ibind(function(next) {\n                fs.stat(scriptPath, abind(function(err, stat) {\n                    deps.push({path: scriptPath, mtime: stat.mtime.getTime()});\n\n                    fs.readFile(scriptPath, 'utf8', abind(function(err, data) {\n                        var compress = options.js == \"compress\";\n                        this.wrapScript(scriptPath, modulePath, data, options, abind(function(err, result) {\n                            var headers = [result.header];\n                            var bodies = [result.body];\n                            var source = this._concatScript(modulePath, [], headers, bodies, options);\n                            next(0, source);\n                        }, next, this));\n                    }, next, this));\n                }, next, this));\n            }, cb, this)\n        ], abind(function(err, sources) {\n            var source = sources.join('\\n');\n            cb(0, {path: 'all.js', source: source, dependencies: deps});\n        }, cb, this));\n    },\n\n    renderScriptInline: function(scriptPath, modulePath, options, cb) {\n        var sandbox = [];\n        var headers = [];\n        var bodies = [];\n        var deps = [];\n\n        async.waterfall([\n            ibind(function(next) {\n                options.featureMap = options.userAgent && this.app.featureDB\n                    // For client-side rendering, attempt to find a precomputed feature map\n                    ? this.app.featureDB.getFeatureMap(options.userAgent, true)\n                    // For server-side rendering, the only feature supported is \"appjs\"\n                    : {appjs: 1};\n\n                this._loadURL(this.app.polyfillsPath, options, next);\n            }, cb, this),\n\n            ibind(function(polyfillsData, next) {\n                deps.push.apply(deps, polyfillsData.dependencies);\n\n                sandbox.push(polyfillsData.body);\n\n                this._loadURL(this.app.resourceBase, options, next);\n            }, cb, this),\n\n            ibind(function(appjsData, next) {\n                deps.push.apply(deps, appjsData.dependencies);\n\n                sandbox.push(appjsData.body);\n\n                if (!options.featureMap) {\n                    this._loadURL(this.app.hasPath, options, next);\n                } else {\n                    next(0, '');\n                }\n            }, cb, this),\n\n            ibind(function(hasjsData, next) {\n                if (hasjsData) {\n                    deps.push.apply(deps, hasjsData.dependencies);\n                    sandbox.push(hasjsData.body);\n                }\n\n                this._inlineScript(scriptPath, modulePath, deps, options, next);\n            }, cb, this),\n\n            ibind(function(result, next) {\n                bodies.push(result.source);\n\n                if (options.js == \"standalone\") {\n                    this.renderStylesheet({css: \"inline\", images: options.images}, abind(function(err, result) {\n                        sandbox.push(\"\"\n                            + \"(function() {\"\n                            + \"var ss = document.createElement('style');\"\n                            + \"ss.innerHTML = \" + JSON.stringify(result.source) + \";\"\n                            + \"document.head.appendChild(ss);\"\n                            + \"})();\");\n                        next(0);\n                    }, cb, this));\n                    next(0);\n                } else {\n                    next(0);\n                }\n            }, cb, this),\n        ],\n        abind(function(err, result) {\n            if (options.js == \"worker\") {\n                bodies.push(\"self.startup('\" + modulePath + \"');\");\n            }\n\n            var source = this._concatScript(modulePath, sandbox, headers, bodies, options);\n            cb(0, {path: 'all.js', source: source, dependencies: deps});\n        }, cb, this));\n    },\n\n    renderStylesheet: function(options, cb) {\n        var sections = [];\n        var deps = [];\n\n        var cssMap = this.app.dependencies.css||{};\n        async.map(_.keys(cssMap),\n            _.bind(function(depPath, cb2) {\n            pkg.searchStatic(depPath, this.app.paths, false, abind(function(err, filePath) {\n                    deps.push({path: filePath, mtime: cssMap[depPath].mtime});\n\n                    fs.readFile(filePath, 'utf8', abind(function(err, data) {\n                        if (options.css == \"inline\" || options.css == \"compress\") {\n                            this.compressCSS(data+'', depPath, options,\n                                function(err, data) {\n                                    sections.push(data);\n                                    cb2(0);\n                                }\n                            );                              \n                        } else {\n                            sections.push(data+'');\n                            cb2(0);\n                        }\n                    }, cb, this));\n                }, cb, this));\n            }, this),\n            abind(function(err) {\n                var source = sections.join('');\n                cb(0, {path: 'all.css', source: source, dependencies: deps});\n            }, cb, this)\n        );\n    },\n\n    renderAppcache: function(options, cb) {\n        cb(0, {\n            source: [\n            'CACHE MANIFEST',\n            '/favicon.ico',\n            this.renderURL(this.app.jsPath, 'js'),\n            this.renderURL(this.app.cssPath, 'css'),\n            ((this.app.appcache||{})['CACHE']||[]).join('\\n'),\n            '',\n            'NETWORK:',\n            ((this.app.appcache||{})['NETWORK']||[]).join('\\n'),\n            '*',\n            '',\n\n            'FALLBACK:',\n            ((this.app.appcache||{})['FALLBACK']||[]).join('\\n'),\n\n            ].join('\\n')\n        });\n    },\n\n    renderContent: function(URL, html, options, cb) {\n        if (options.content == \"inline\") {\n            this.app.getContentScript(this, abind(function(err, script) {\n                this._runInSandbox(script, URL, html, cb);\n            }, cb, this));\n        } else {\n            cb(0, html);\n        }\n    },\n\n    compressJavaScript: function(source, options) {\n        try {\n            // XXXjoe Don't use filters if we already stripped has calls when inlining\n            var filters = options.featureMap && this.app.stripFeatures\n                ? [hascan.getHasFilter(options.featureMap)]\n                : [];\n            var minify = 'minify' in options ? options.minify : true;\n            var beautify = 'beautify' in options ? options.beautify : false;\n            var ast = transformjs.transform(source, filters);\n            return transformjs.generate(ast, minify, beautify);\n        } catch (exc) {\n            console.error('Error compressing JavaScript', exc);\n            return source;\n        }\n    },\n    \n    compressCSS: function(source, baseURL, options, cb) {\n        pkg.traceStylesheet(baseURL, this.app.paths, false, source, null, abind(inlineImages, cb, this));\n\n        function inlineImages(err, deps) {\n            async.map(_.keys(deps.images),\n                _.bind(function(imagePath, cb2) {\n                    var imageURL = this.renderURL(this.app.staticPath + '/' + imagePath, 'images');\n                    var sourceURL = deps.images[imagePath].sourceURL;\n                    if (options.images == \"inline\") {\n                        this._loadURL(imageURL, {}, _.bind(function(err, result) {\n                            var maxSize = this.app.inlineImageMaxSize;\n                            if (!err && maxSize && result.body && result.body.length > maxSize) {\n                                // Load the image externally if it's too large\n                                source = source.replace(sourceURL, imageURL); \n                            } else {\n                                // Inline the image if it is less than the maximum size\n                                var dataURL = err ? imageURL : encodeDataURL(result.path, result.body);\n                                source = source.replace(sourceURL, dataURL); \n                            }\n                            cb2(0);\n                        }, this));\n                    } else if (options.images == \"source\") {\n                        source = source.replace(sourceURL, imageURL);    \n                        cb2(0);\n                    } else {\n                        cb2(0);\n                    }\n                }, this),\n                _.bind(function(err) {\n                    inlineStylesheets.apply(this, [deps]);\n                }, this)\n            );\n        }\n\n        function inlineStylesheets(deps) {\n            if (options.css == \"inline\") {\n                async.map(_.keys(deps.css),\n                    _.bind(function(stylesheetPath, cb2) {\n                        // Remove the @import line, since renderStylesheet inlines the imported contents\n                        source = source.replace(deps.css[stylesheetPath].sourceLine, '');   \n                        cb2(0);\n                    }, this),\n                    _.bind(function(err) {\n                        complete.apply(this);       \n                    }, this)\n                );\n            } else {\n                complete.apply(this);\n            }\n        }\n\n        function complete() {\n            if (options.css == \"inline\" || options.css == \"compress\") {\n                source = cssmin(source);\n            }\n            cb(0, source);\n        }\n    },\n\n    /**\n     * Inlines the script with all of its dependencies, found recursively.\n     */\n    _inlineScript: function(scriptPath, modulePath, deps, options, cb) {\n        var absoluteModulePath = require.resolve(modulePath);\n        var modules = {};\n\n        this._inlineModule(scriptPath, modulePath, modules, deps, options,\n            abind(function(err, result) {\n                var sources = _.values(modules);\n\n                var inlinedSource = sources.join('\\n');\n                cb(0, {source: inlinedSource, dependencies: deps});            \n            }, cb, this)\n        );\n    },\n\n    _inlineModule: function(scriptPath, modulePath, modules, deps, options, cb) {\n        var required = {};\n        var ast;\n\n        async.waterfall([\n            ibind(function(next) {\n                fs.lstat(scriptPath, next);\n            }, cb, this),\n            \n            ibind(function(stat, next) {\n                deps.push({path: scriptPath, mtime: stat.mtime.getTime()});\n\n                fs.readFile(scriptPath, 'utf8', next);\n            }, cb, this),\n\n            ibind(function(data, next) {\n                // Search for require calls and remember \n                ast = transformjs.transform(data+'', [\n                    hascan.getHasFilter(options.featureMap),\n                    function(node, next) {\n                        var pathNode = findRequireNode(node);\n                        if (pathNode) {\n                            required[pathNode.value] = '';                            \n                        }\n                        return next();\n                    }\n                ]);\n\n                async.map(_.keys(required), ibind(function(requiredPath, cb2) {\n                    pkg.searchScript(requiredPath, scriptPath, abind(function(err, result) {\n                        // Remember absolute name of module so we can make it absolute later\n                        required[requiredPath] = result.name;\n                        cb2(0, result);\n                    }, cb, this));  \n                }, cb, this), next);\n            }, cb, this),\n\n            ibind(function(results, next) {\n                ast = transformjs.transform(ast, [\n                    function(node, next) {\n                        var pathNode = findRequireNode(node);\n                        if (pathNode) {\n                            // Convert potentially relative require paths to their normalized form so\n                            // that they can be found in the module cache\n                            pathNode.value = required[pathNode.value];\n                        }\n                        return next();\n                    }\n                ]);\n\n                var newSource = transformjs.generate(ast, false, true);\n                if (options.js == \"standalone\") {\n                    modules[scriptPath] =\n                        '(function(require, exports, module, globals) {'\n                        + newSource + '})(require, self, {exports: self});';\n                } else {\n                    modules[scriptPath] =\n                        'define(\"' + modulePath + '\", function(require, exports, module, globals) {'\n                        + newSource + '});';\n                }\n\n                async.forEach(results, ibind(function(info, cb2) {\n                    if (info.path in modules) {\n                        cb2(0);\n                    } else {\n                        this._inlineModule(info.path, info.name, modules, deps, options, cb2);\n                    }\n                }, cb, this), cb);\n            }, cb, this)\n        ], cb);\n    },\n\n    _concatScript: function(modulePath, sandbox, headers, bodies, options) {\n        var inlined = options.js == \"inline\" || options.js == \"standalone\" || options.js == \"worker\";\n\n        var source = \n            sandbox.join('\\n')\n            + '(function() {'\n                + headers.join('\\n') + bodies.join('\\n')\n            + '})();';\n\n        if (inlined || options.js == \"compress\") {\n            source = this.compressJavaScript(source, options);\n        }\n\n        if (inlined && this.app.jsHeader) {\n            source = this.app.jsHeader + '\\n' + source;\n        }\n\n        return source;\n    },\n\n    _scriptTags: function(urlPaths, options, cb) {\n        var params = [];\n        if (options.js != this.app.js) {\n            params.push(\"js=\" + options.js);\n        }\n\n        var q = (params.length ? '?' + params.join('&') : '');\n\n        var tags = [];\n\n        if (options.loader == \"dynamic\") {\n            var baseURL = this.renderURL(this.app.jsPath, null, true);\n            tags.push(scriptTagForSource('self.appjsBase=' + JSON.stringify(baseURL)));\n        }\n        if (this.app.appVersion) {\n            var version = this.app.appVersion;\n            tags.push(scriptTagForSource('self.appjsVersion=' + JSON.stringify(version)));\n        }\n        if (options.js == \"inline\") {\n            tags.push(scriptTagForURL(this.renderURL(this.app.jsPath, 'js')));\n        } else {\n            tags.push(scriptTagForURL(this.renderURL(this.app.polyfillsPath)));\n            tags.push(scriptTagForURL(this.renderURL(this.app.hasPath)));\n\n            tags.push.apply(tags, _.map(urlPaths, _.bind(function(url) {\n                return scriptTagForURL(this.renderURL(url));\n            }, this)));\n\n            var mainModuleName = this.app.jsPath + '/' + this.app.client;\n            tags.push(scriptTagForURL(this.renderURL(mainModuleName)));\n            if (this.app.socket) {\n                tags.push(scriptTagForSource('require.listen(\"ws://' + this.app.socket + '\")'));\n            }\n        }\n\n        cb(0, tags.join('\\n'));\n\n        function scriptTagForURL(urlPath) {\n            // XXXjoe Disabling user-agent URLs for the time being\n            if (false && options.js == \"inline\") {\n                // Inject the user-agent into the url so it can pass through CDN and bust caches\n                return scriptTagForSource(\n                    'document.write('\n                    + '\\'<script type=\"text/javascript\" src=\"\\' + \\''\n                    + urlPath + q\n                    + '\\'.replace(/(app\\\\.js(\\\\.\\\\d+)?)/, \\'$1:\\' + '\n                    + 'navigator.userAgent.replace(/\\\\//g, \"%2f\")' + \n                    ') + \"\\\\\"></\" + \"script>\")');\n            } else {\n                return '<script type=\"text/javascript\" src=\"' + urlPath + q + '\"></script>';\n            }\n        }\n\n        function scriptTagForSource(src) {\n            return '<script type=\"text/javascript\">' + src + '</script>';\n        }\n    },\n\n    _processedScriptTags: function(items) {\n        // XXXjoe So far we only support processed stylesheets\n        return '';\n    },\n\n    _styleTags: function(options, cb) {\n        var params = [];\n        if (options.css != this.app.css) {\n            params.push('css=' + options.css);          \n        }\n        if (options.images != this.app.images) {\n            params.push('images=' + options.images);\n        }\n        var q = (params.length ? '?' + params.join('&') : '');\n\n        if (options.css == \"inline\") {\n            var stylesheetURL = this.renderURL(this.app.cssPath + q, 'css');\n            var tag = '<link rel=\"stylesheet\" href=\"' + stylesheetURL + '\">';\n            cb(0, tag);\n        } else {\n            var tags = _.map(this.app.dependencies.css, _.bind(function(dep, urlPath) {\n                var stylesheetPath = this.app.staticPath + '/' + urlPath;\n                var stylesheetURL = this.renderURL(stylesheetPath + q);\n                return '<link rel=\"stylesheet\" href=\"' + stylesheetURL + '\">';\n            }, this)).join('\\n');\n            cb(0, tags);\n        }\n    },\n\n    _iconTags: function(options, cb) {\n        if (options.icons == \"source\") {\n            var tags = _.map(this.app.dependencies.icons, _.bind(function(dep, iconName) {\n                var iconPath = this.app.staticPath + '/' + this.app.packageName +'/' + iconName;\n                var iconURL = this.renderURL(iconPath, 'icons');\n                return this._tagForIconURL(iconName, iconURL);\n            }, this)).join('\\n');\n            cb(0, tags);\n        } else if (options.icons == \"inline\") {\n            async.map(_.keys(this.app.dependencies.icons),\n                _.bind(function(iconName, cb2) {\n                    var iconPath = this.app.staticPath + '/' + this.app.packageName + '/' + iconName;\n                    var iconURL = this.renderURL(iconPath, 'url');\n                    this._loadURL(iconURL, {}, abind(function(err, result) {\n                        var dataURL = err\n                            ? iconURL\n                            : encodeDataURL(result.path, result.body);\n                        cb2(0, this._tagForIconURL(iconName, dataURL));\n                    }, cb, this));                      \n                }, this),\n                abind(function(err, iconTags) {\n                    cb(0, iconTags.join('\\n'));     \n                })\n            );                  \n        } else {\n            cb(0, '');\n        }\n    },\n\n    _processedStyleTags: function(items) {\n        return '';      \n    },\n\n    _runInSandbox: function(script, URL, html, cb) {\n        var pending = 0;\n        var finished = false;\n\n        var document = jsdom(html, null, {\n            features: {\n                FetchExternalResources: false,\n                ProcessExternalResources: false,\n                MutationEvents: false,\n                QuerySelector: ['1.0']\n            }\n        });\n\n        var window = document.createWindow();\n\n        window.appjs = {\n            moduleName: this.app.client,\n            href: URL,\n\n            lookup: function(moduleName, baseName, cache) {\n                if (baseName && moduleName[0] == '.') {\n                    var basePath = require.resolve(baseName);\n                    moduleName = path.resolve(path.dirname(basePath), moduleName);\n                }\n\n                var scriptPath = require.resolve(moduleName);\n                if (scriptPath in cache) {\n                    return cache[scriptPath];\n                } else {\n                    var source = fs.readFileSync(scriptPath, 'utf8');\n                    return cache[scriptPath] = {name: moduleName, path: scriptPath, source: source};\n                }\n            },\n\n            load: _.bind(function(href, method, headers, params, cbLoaded) {\n                ++pending;\n\n                var hrefParsed = url.parse(href, true);\n                if (hrefParsed.hostname != document.location.hostname) {\n                    fail({error: 500, body: \"Only local hosts can be reached.\"});\n                } else {\n                    var options = {\n                      host: hrefParsed.hostname || defaultHost,\n                      port: hrefParsed.port || defaultPort,\n                      path: hrefParsed.pathname + hrefParsed.search,\n                    };\n\n                    // If loadURL doesn't return fast enough we stop waiting for it and move on...\n                    var timedOut = false;\n                    var timeout = setTimeout(function() {\n                        timedOut = true;\n                        if (!--pending) {\n                            finish(window.appjs.html);\n                        }\n                    }, loadTimeout);\n\n                    process.nextTick(ibind(function() {\n                        this._loadFromAPI(hrefParsed.pathname, method, headers, hrefParsed.query, params,\n                            ibind(function(err, result) {\n                                cbLoaded(err, result);\n                                completeRequest();\n                            }, cb, this)\n                        );\n                    }, cb, this));\n\n                    function completeRequest() {\n                        clearTimeout(timeout);\n                        if (!timedOut && !--pending) {\n                            var body = docType + '\\n' + domToHtml(document, true);\n                            finish(body);\n                        }\n                    }\n                }\n            }, this),\n        };\n\n        function finish(body) {\n            finished = true;\n            if (!document.statusCode || document.statusCode == 200) {\n                cb(0, body);\n            } else {\n                cb({error: document.statusCode, body: body});\n            }\n        }\n\n        window.document.baseURI = this.baseURLPath;\n        // Yay, url.parse returns object with same properties as window.location object\n        _.extend(window.location, URL);\n\n        // XXXjoe Seems the console built into window does not log to stdout\n        window.console = console;\n\n        // XXXjoe These are buggy as of jsdom 0.2.0\n        window.addEventListener = function() {}\n        window.removeEventListener = function() {}\n\n        var context = script.runInNewContext(window);\n\n        // If no requests are pending, the page is done!\n        if (!pending && !finished) {\n            cb(0, window.appjs.html);\n        }\n    },\n\n    _loadURL: function(URL, options, cb) {\n        this.app.loadURL(URL, this, options, cb);\n    },\n\n    _loadFromAPI: function(href, method, headers, query, params, cb) {\n        if (this.apiCache && (!method || method.toUpperCase() == \"GET\")) {\n            this.apiCache.load(href, ibind(function(err, entry) {\n                if (err || !entry || !entry.body || !entry.body.length) {\n                    callAPI.apply(this);\n                } else {\n                    var body = typeof(entry.body) == 'object' ? entry.body+'' : entry.body;\n                    cb(0, body);\n                }\n            }, cb, this));        \n        } else {\n            callAPI.apply(this);\n        }\n\n        function callAPI() {\n            this.api.call(method, href, headers, query, params, {},\n                ibind(function(err, result) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        var body = result.body;\n                        body = (query.callback || '') + '(' + body + ')';\n                        \n                        var entry = {\n                            key: href,\n                            headers: {\n                                etag: result.etag,\n                                cacheControl: result.cacheControl\n                            },\n                            mimeType: \"application/x-javascript; charset=UTF-8\",\n                            body: body\n                        };\n\n                        if (this.apiCache) {\n                            this.apiCache.store(href, entry,\n                                ibind(function(err) {\n                                    cb(0, body);\n                                }, this)\n                            );\n                        } else {\n                            cb(0, body);\n                        }\n                    }\n                }, cb, this)\n            );            \n        }\n    },\n\n    _renderResources: function(processedMap, options, cb) {\n        this._scriptTags(this.builtinScripts, options, _.bind(function(err, scriptTags) {\n            this._styleTags(options, _.bind(function(err, styleTags) {\n                this._iconTags(options, _.bind(function(err, iconTags) {\n                    scriptTags += this._processedScriptTags(processedMap);\n                    styleTags += this._processedStyleTags(processedMap);\n                    cb(0, {scripts: scriptTags, stylesheets: styleTags, icons: iconTags});\n                }, this));\n            }, this));\n        }, this));\n    },\n\n    _renderPage: function(processedMap, options, cb) {\n        this._renderResources(processedMap, options, _.bind(function(err, result) {\n            var scriptTags = '';\n            if (options.content == \"inline\") {\n                scriptTags = '';\n            } else {\n                scriptTags += this._processedScriptTags(processedMap);\n            }\n\n            cb(0, \n                docType+'\\n'+\n                '<html'+\n                (this.app.language\n                    ? ' lang=\"'+this.app.language+'\"' : '')+\n                (this.app.offline && options.content != \"inline\"\n                    ? ' manifest=\"' + this.renderURL(this.app.appcachePath) + '\"' : '')+\n                '>\\n'+\n                '<head>\\n'+\n                (this.app.charset\n                    ? '<meta charset=\"'+this.app.charset+'\">\\n'\n                    : '')+\n                (this.app.title\n                    ? '<title>'+this.app.title+'</title>\\n'\n                    : '')+\n                '<base href=\"'+this.baseURLPath+'\">\\n'+\n                result.icons+'\\n'+\n                (this.app.viewport\n                    ? '<meta id=\"viewport\" name=\"viewport\" content=\"'+this.app.viewport+'\">\\n'\n                    : '')+\n                (this.app.webAppCapable\n                    ? '<meta name=\"apple-mobile-web-app-capable\" content=\"true\">\\n'\n                    : '')+\n                (this.app.statusBarStyle\n                    ? '<meta name=\"apple-mobile-web-app-status-bar-style\" '+\n                      'content=\"'+this.app.statusBarStyle+'\">\\n'\n                    : '')+\n                (this.app.rss\n                    ? '<link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"'\n                      + this.app.rss + '\">\\n' : '')+\n                result.stylesheets+'\\n'+\n                result.scripts+'\\n'+\n                (this.app.htmlHeader\n                    ? this.app.htmlHeader+'\\n'\n                    : '')+\n                '</head>\\n'+\n                '<body>\\</body>\\n'+\n                '</html>'\n            );\n        }, this));\n    },\n\n    /**\n     * Wraps a script in an AMD define call that will load each dependency in a separate request.\n     *\n     * require calls are found with a regex, which will pull in requires that are commented out\n     * or inside of has('feature') branches that are never called.  Since this outputs code meant\n     * for debugging, the imprecision is forgivable.\n     */\n    wrapScript: function(scriptPath, modulePath, source, options, cb) {\n        var m, deps = [], depPaths = [];\n        source = source+'';\n        while (m = reRequire.exec(source)) {\n            depPaths.push(m[1]);\n            deps.push(m);\n        }\n\n        async.map(depPaths,\n            _.bind(function(depPath, cb2) {\n                pkg.searchScript(depPath, scriptPath, cb2);\n            }, this),\n            abind(function(err, absolutePaths) {\n                // Replace require statements with argument names of modules\n                var depStrings = [];\n                for (var i = 0; i < deps.length; ++i) {\n                    var name = absolutePaths[i].name;\n                    source = source.replace(deps[i][0], 'require(\"'+name+'\")');\n                    depStrings.push('\"' + name + '\"');\n                }\n\n                var params = [\"require\", \"exports\", \"module\", \"globals\"];\n\n                source = '(function(' + params.join(', ') + ') {' + source + '})';\n\n                var body = 'define(\"' + modulePath + '\", ['\n                           + depStrings.join(', ') + '], ' + source + ');';\n                cb(0, {header: '', body: body});\n            }, cb, this)\n        );          \n    },\n    \n    _getLatestTimestamp: function(category, isStatic) {\n        if (!category) {\n            return isStatic ? null : this.app.startupTime;\n        } else if (category in this.app.dependencies) {\n            var maxTime = 0;\n            _.each(this.app.dependencies[category], function(dep) {\n                if (dep.mtime > maxTime) {\n                    maxTime = dep.mtime;\n                }\n            });\n            return maxTime;\n        } else {\n            return 0;\n        }\n    },\n\n    _urlForCDN: function(URL, category, isStatic, timestamp) {\n        var parsed = url.parse(URL);\n        var path = parsed.pathname;\n\n        if (!timestamp) {\n            if (this.app.appVersion) {\n                timestamp = isStatic ? null : this.app.appVersion;\n            } else {\n                timestamp = this._getLatestTimestamp(category, isStatic);                \n            }\n        }\n        if (timestamp) {\n            path += ':' + timestamp;\n        }\n        parsed.protocol = 'http';\n        parsed.host = this.app.cdn;\n        parsed.pathname = path;\n\n        return url.format(parsed);\n    },\n\n    renderURL: function(URL, category, isStatic, timestamp) {\n        if (this.app.cdn) {\n            return this._urlForCDN(URL, category, isStatic, timestamp);\n        } else {\n            return URL;\n        }\n    },\n\n    _tagForIconURL: function(iconName, iconURL) {\n        var m;\n        if (iconName == \"favicon.ico\") {\n            return '<link rel=\"shortcut icon\" href=\"' + iconURL + '\">';\n        } else if (m = /apple-touch-icon(-(\\d+x\\d+))?-precomposed\\.png/.exec(iconName)) {\n            var sizesAttr = m[2] ? ' sizes=\"'+m[2]+'\"' : '';\n            return '<link rel=\"apple-touch-icon-precomposed\"'+sizesAttr+' href=\"' + iconURL + '\">';\n        } else if (m = /apple-touch-icon(-(\\d+x\\d+))?\\.png/.exec(iconName)) {\n            var sizesAttr = m[2] ? ' sizes=\"'+m[2]+'\"' : '';\n            return '<link rel=\"apple-touch-icon\"'+sizesAttr+' href=\"' + iconURL + '\">';\n        } else if (m = /apple-touch-startup-image(-(\\d+x\\d+))?\\.png/.exec(iconName)) {\n            var sizesAttr = m[2] ? ' sizes=\"'+m[2]+'\"' : '';\n            return '<link rel=\"apple-touch-startup-image\"'+sizesAttr+' href=\"' + iconURL + '\">';\n        } else {\n            return '';\n        }\n    }\n};\n\n// *************************************************************************************************\n\nfunction findRequireNode(node) {\n    if (node.TYPE == 'Call' && node.expression.TYPE == 'SymbolRef'\n        && node.expression.name == 'require') {\n        var args = node.args;\n        if (args.length == 1) {\n            var pathNode = args[0];\n            if (pathNode.TYPE == 'String') {\n                return pathNode;\n            }\n        }\n    }        \n}\n\nfunction addTrailingSlash(s) {\n    if (s && s.substr(s.length-1) == '/') {\n        return s;\n    } else {\n        return s + '/';\n    }\n}\n\nfunction encodeDataURL(sourcePath, source) {\n    var mimeType = sourcePath ? mime.lookup(sourcePath) : '';\n    var buf = new Buffer(source, 'binary');\n    var b64 = buf.toString('base64');\n    return '\"data:'+mimeType+';base64,'+b64+'\"';\n}","/home/travis/build/npmtest/node-npmtest-app.js/node_modules/app.js/lib/utils.js":"\nvar dandy = require('dandy/errors'),\n\t_ = require('underscore'),\n    async = require('async'),\n    fs = require('fs'),\n\tutil = require('util'),\n    mime = require('mime');\n\n// *************************************************************************************************\n\nvar defaultMimeType = 'text/plain';\nvar htmlMimeType = 'text/html';\n\nvar reCDNs = /Amazon\\sCloudFront/i;\n\nvar debugMode = process.env.NODE_ENV != 'production';\n\n// *************************************************************************************************\n\nexports.sendSafely = function(cb) {\n    var res = this;\n    var req = res.req;\n    try {\n        return cb(sbind(function(err, result) {\n            if (err) {\n                sendError(req, res, err, typeof(err) == 'object' ? err.error : 500, result);\n            } else if (result.path) {\n            \tsendFile(req, res, result);\n            } else {\n                sendData(req, res, result);\n            }\n        }, this));\n    } catch (exc) {\n        sendError(req, res, exc);\n    }\n\n    function sbind(fn, self) {\n        return function() {\n            try {\n                return fn.apply(self, arguments);\n            } catch (exc) {\n                sendError(req, res, exc);                    \n            }\n        }\n    }\n}\n\nfunction sendFile(req, res, result) {\n\tvar mimeType = result.mimeType || (result.path\n\t    ? mime.lookup(result.path) || defaultMimeType\n\t    : htmlMimeType);\n\n\tif (isTextMimeType(mimeType)) {\n\t    mimeType += '; charset=UTF-8'\n\t}\n\n\tres.header('Content-Type', mimeType);\n\n\tvar deps = result.dependencies || [];\n\n    if (result.permanent || isCDN(req)) {\n        res.header('Cache-Control', 'public, max-age=31536000');\n    } else {\n        res.header('Cache-Control', 'public, max-age=0');\n    }\n\n    async.waterfall([\n    function(next) {\n        fs.stat(result.path, next);\n    },\n    function(stat, next) {\n        res.header('ETag', stat.mtime.getTime());\n\n        if (!result.body) {\n            fs.readFile(result.path, next);\n        } else {\n            next(0);\n        }\n    },\n    function(body) {\n        if (body) {\n            result.body = body;\n        }\n        res.send(result.body, result.error || 200); \n    }\n    ], function(err) {\n        sendError(req, res, err, 500);\n    });\n}\n\nfunction sendData(req, res, result) {\n    res.header('Content-Type', result.mimeType || htmlMimeType);\n\n    if (result.dependencies) {\n        res.dependencies = _.pluck(result.dependencies, 'path');\n\n        var latestTime = findLatestMtime(result.dependencies || []);\n        if (latestTime) {\n            res.header('ETag', latestTime);\n        }\n    } else if (result.etag) {\n        res.header('ETag', result.etag);\n    }\n\n    // if (result.permanent) {\n        res.header('Cache-Control', 'public, max-age=31536000');\n    // } else {\n    //     res.header('Cache-Control', 'public, max-age=0');\n    // }\n\n    res.send(result.body, 200);\n}\n\nfunction sendError(req, res, err, code, result) {\n    dandy.logException(err,\n        \"Error while loading \" + req.url + \"\\n\" + util.inspect(req.headers));\n\n    var body = result && result.body ? result.body : 'Error';\n    res.header('Content-Type', result && result.mimeType ? result.mimeType : htmlMimeType);\n    res.send(body, code || 500);\n}\n\nfunction findLatestMtime(dependencies) {\n    var maxTime = 0;\n    _.each(dependencies, function(dep) {\n        if (dep.mtime > maxTime) {\n            maxTime = dep.mtime;\n        }\n    });\n    return maxTime;\n}\n\nfunction isTextMimeType(mimeType) {\n    return mimeType.indexOf('text/') == 0\n        || mimeType == 'application/json'\n        || mimeType == 'application/javascript'\n        || mimeType == 'application/x-javascript';\n}\n\nfunction isCDN(req) {\n    var userAgent = req.headers['user-agent'];\n    return !!reCDNs.exec(userAgent);\n}\n\n","/home/travis/build/npmtest/node-npmtest-app.js/node_modules/app.js/client/appjs-dynamic.js":"/**\n * This is the development version of app.js which supports dynamic loading of modules and dependency resolution.\n */\n\nif (!self.has) {\n    self.has = function(feature) { \n        // XXXjoe Temporary hack until we include has.js with inlined scripts\n        if (feature == \"dom-addeventlistener\") {\n            return true;\n        } else {\n            return false;            \n        }\n    }\n}\n\n// *************************************************************************************************\n\n(function() {\n\nvar frozen = {};\nvar queuedName;\n\nfunction define(name, deps, factory) {\n    if (!factory) {\n        if (typeof(deps) == \"function\") {\n            factory = deps;\n            deps = null;\n        }\n    }\n\n    // This implies that the first module to be defined will be the \"root module\".\n    // It would be better if this were more explicit.\n    if (!queuedName) {\n        queuedName = name;\n    }\n\n    if (typeof(factory) == \"string\") {\n        var source = factory;\n        factory = function() { return sandboxEval(source).apply(this, arguments); }\n    }\n\n    frozen[name] = {deps:deps, factory:factory};\n}\nself.define = define;\n\ndefine.env = function(moduleName, globals) {\n    var require = createEnvironment(frozen, globals||{});\n    return require(moduleName);\n}\n\nself.addEventListener(\"DOMContentLoaded\", function() {\n    if (queuedName) {\n        define.env(queuedName, self);\n    }\n});\n\n// *************************************************************************************************\n\nfunction createEnvironment(frozen, globals) {\n\nvar mainModule;\nvar modules = {};\nvar moduleCallbacks = {};\nvar defining = {};\nvar generators = [];\nvar readies = [];\nvar observers = [];\n\nfunction require(name, timestamp, cb) {\n    if (typeof(timestamp) == 'function') {\n        cb = timestamp;\n        timestamp = null;\n    }\n\n    name = require.resolve(name);\n    if (modules[name]) {\n        var module = modules[name];\n        if (cb) {\n            cb(0, module);\n        } else {\n            return module.exports;\n        }\n    } else {\n        loadScript(name, timestamp, cb);\n        var module = modules[name];\n        return module ? module.exports : null;\n    }        \n}\n\nrequire.reload = function(name) {\n    for (var i = 0; i < observers.length; ++i) {\n        if (!observers[i](name, true)) {\n            return;\n        }\n    }\n\n    delete modules[name];\n    require(name, new Date().getTime(), function(err, module) {\n        if (!err) {\n            for (var i = 0; i < observers.length; ++i) {\n                observers[i](module);\n            }\n        }\n    });    \n};\n\nrequire.observe = function(fn) {\n    observers.push(fn);\n};\n\nrequire.unobserve = function(fn) {\n    var index = observers.indexOf(fn);\n    if (index >= 0) {\n        observers.splice(index, 1);        \n    }\n};\n\nrequire.stylesheet = function(url) {\n    var ss = document.createElement('link');\n    ss.rel = \"stylesheet\";\n    ss.href = url;\n    document.head.appendChild(ss);\n};\n\nrequire.listen = function(url) {\n    var connection = new WebSocket(url);\n    connection.onmessage = function (e) {\n        var data = JSON.parse(e.data);\n        // console.log('message', data);\n        if (data.name == 'reload') {\n            window.location.reload();\n        } else if (data.name == 'invalidate') {\n            if (data.URL.indexOf(appjsBase) == 0) {\n                // XXXXjoe Disable script reloading for now\n                var moduleName = urlToModuleName(data.URL);\n                require.reload(moduleName);\n            } else if (data.URL.lastIndexOf('css') == data.URL.length - 3) {\n                // console.log('refresh', data.URL);\n                require.stylesheet(data.URL);\n            }\n        }\n    };\n};\n\nrequire.ready = function(cb) {\n    readies[readies.length] = cb;\n};\n\n// XXXjoe We probably don't need this since I don't think we leave relative requires in anymore\nrequire.resolve = function(name, baseName) {\n    if (name[0] == '.') {\n        // Relative paths inside of root modules are contained within the module, not its parent\n        var absolutePath = baseName.indexOf('/') == -1 ? baseName : dirname(baseName);\n        \n        var parts = name.split('/');\n        for (var i = 0; i < parts.length; ++i) {\n            var part = parts[i];\n            if (part == '.') {\n            } else if (part == '..') {\n                absolutePath = dirname(absolutePath);\n            } else {\n                absolutePath = absolutePath + '/' + part;\n            }\n        }\n        return absolutePath;\n    } else {\n        return name;\n    }\n};\n\nrequire.addGenerator = function(callback) {\n    generators[generators.length] = callback;\n};\n\nrequire.generate = function() {\n    var texts = [];\n    for (var i = 0; i < generators.length; ++i) {\n        texts[texts.length] = generators[i]();\n    }\n    return JSON.stringify(texts);\n};\n\nrequire.getModuleId = function(module) {\n    for (var name in modules) {\n        if (modules[name].exports == module) {\n            return name;\n        }\n    }\n};\n\n// *************************************************************************************************\n\nfunction addModuleCallback(name, callback) {\n    var firstCallback = false;\n\n    var callbacks = moduleCallbacks[name];\n    if (!callbacks) {\n        moduleCallbacks[name] = [];\n        firstCallback = true;\n    }\n\n    if (callback) {\n        moduleCallbacks[name].push(callback);\n    }\n    return firstCallback;\n}\n\nfunction loadScript(name, timestamp, cb) {\n    if (name in modules) {\n        var module = modules[name];\n        if (cb) {\n            cb(0, module);\n        } else {\n            return module.exports; \n        }\n    } else if (name in frozen && !(name in defining)) {\n        addModuleCallback(name, cb);\n        return thaw(name);\n    } else {\n        if (addModuleCallback(name, cb)) {\n            if (has('appjs')) {\n                throw new Error(\"Not found\");\n            } else {\n                var search = location.search;\n                var url = urlForScript(name, timestamp) + (search ? search + '&' : '');\n\n                var script = document.createElement('script');\n                script.type = 'text/javascript';\n                script.async = true;\n                script.src = url;\n                script.onload = function() {\n                    if (script.parentNode) {\n                        script.parentNode.removeChild(script);\n                    }\n                    thaw(name);\n                };\n                script.onerror = function() {\n                    if (script.parentNode) {\n                        script.parentNode.removeChild(script);\n                    }\n                    dispatchModuleError(name, new Error());\n                };\n\n                var head = document.getElementsByTagName(\"head\")[0];\n                head.appendChild(script);\n            }\n        }\n    }\n}\n\nfunction thaw(name) {\n    var cached = frozen[name];\n    if (cached) {\n        // delete frozen[name];\n\n        if (!mainModule) {\n            mainModule = name;\n        }\n        \n        return defineModule(name, cached.deps, cached.factory);\n    } else {\n        dispatchModuleError(name, new Error());        \n    }\n}\n\nfunction defineModule(name, deps, factory) {\n    defining[name] = true;\n    return loadDependencies(name, deps, function(err) {\n        delete defining[name];\n\n        var module = {id: name, exports: {}};\n        modules[name] = module;\n                \n        function localRequire(name, timestamp, cb) {\n            return require(name, timestamp, cb);\n        }\n        for (var p in require) {\n            localRequire[p] = require[p];\n        }\n\n        require.module = module;\n        factory.apply(self, [localRequire, module.exports, module, globals]);\n        delete require.module;\n\n        dispatchModule(name, module);\n        return module.exports;\n    });\n}\n\nfunction loadDependencies(dependentId, deps, cb) {\n    if (deps && deps.length) {\n        var remaining = deps.length;\n        for (var i = 0; i < deps.length; ++i) {\n            var name = deps[i];\n            if (name == 'require' || name == 'exports' || name == 'module') {\n                if (!--remaining) {\n                    return cb(0);\n                }\n            } else {\n                name = deps[i] = require.resolve(name, dependentId);\n                loadScript(name, null, function(err, module) {\n                    if (!--remaining) {\n                        return cb(err);\n                    }\n                });\n            }\n        }\n    } else {\n        return cb(0);\n    }\n}\n\nfunction dispatchModuleError(name, err) {\n    if (moduleCallbacks[name]) {\n        var callbacks = moduleCallbacks[name];\n        delete moduleCallbacks[name];\n        for (var i = 0; i < callbacks.length; ++i) {\n            callbacks[i](err);\n        }\n    }\n}\n\nfunction dispatchModule(name, module) {\n    if (moduleCallbacks[name]) {\n        var callbacks = moduleCallbacks[name];\n        delete moduleCallbacks[name];\n        for (var i = 0; i < callbacks.length; ++i) {\n            callbacks[i](0, module);\n        }\n    }\n\n    if (name == mainModule) {\n        for (var i = 0; i < readies.length; ++i) {\n            readies[i]();\n        }\n\n        if (has('appjs')) {\n            appjs.html = document.doctype + '\\n' + document.outerHTML;\n        }\n    }\n}\n\nfunction dirname(path) {\n    var index = path.lastIndexOf('/');\n    if (index == -1) {\n        return '';\n    } else {\n        return path.substr(0, index);\n    }\n}\n\nfunction urlToModuleName(URL) {\n    var moduleName = URL.substr(appjsBase.length + 1);\n    var q = moduleName.indexOf('?');\n    moduleName = q != -1 ? moduleName.substr(0, q) : moduleName;\n    var dot = moduleName.lastIndexOf('.');\n    return dot != -1 ? moduleName.substr(0, dot) : moduleName;    \n}\n\nfunction urlForScript(name, timestamp) {\n    var ext = name.substr(name.length-3);\n    if (name.indexOf('.') == -1) {\n        name += '.js';\n    }\n\n    if (timestamp) {\n        name += ':' + timestamp;\n    }\n    return appjsBase + '/' + name;\n}\n\nif (globals) {\n    globals.require = require;    \n}\n\nreturn require;\n\n}\n\n})();\n\n// *************************************************************************************************\n\n/**\n * Eval in a sandbox where global and local application variables are not accessible.\n *\n * This function must be *outside* of all closures that may invoke it, otherwise it will not\n * be a \"sandbox\" because eval will be able to reference variables in the application.\n */\nself.sandboxEval = function(js, sandbox) {\n    if (sandbox) {\n        with (sandbox) {\n            return eval(js);\n        }\n    } else {\n        return eval(js);\n    }\n};\n\n// XXXjoe has.js doesn't have a test for this yet :(\nif (self.document && !document.querySelector) {\n    (function(d){d=document,a=d.styleSheets[0]||d.createStyleSheet();d.querySelectorAll=function(e){a.addRule(e,'f:b');for(var l=d.all,b=0,c=[],f=l.length;b<f;b++)l[b].currentStyle.f&&c.push(l[b]);a.removeRule(0);return c}})();\n}\n    ","/home/travis/build/npmtest/node-npmtest-app.js/node_modules/app.js/client/appjs-standalone.js":"","/home/travis/build/npmtest/node-npmtest-app.js/node_modules/app.js/client/appjs-static.js":"\nif (!self.has) {\n    self.has = function() { return false; }\n}\n\n/**\n * This is the optimized version of app.js which does not allow dynamic loading of modules. All modules must\n * be loaded and defined before the first require() call, or they will not be found.  The benefit of this\n * restriction is that this file is 1/3 the size, and generated modules are smaller because they don't need\n * to include dependency information. Is this tradeoff worth it? Time and more research will tell.\n */\n(function() {\n\nvar modules = {};\nvar frozen = {};\nvar readies = [];\nvar mainModule;\nvar loaded = false;\nvar queuedName;\n\nfunction require(name) {\n    if (name in modules) {\n        return modules[name].exports;\n    } else if (has(\"appjs\")) {\n        // Don't wait for load event to thaw modules when on server\n        return thaw(name);\n    } else if (loaded) {\n        // Wait for load event to thaw modules\n        return thaw(name);\n    }\n}\nself.require = require;\n\nrequire.ready = function(cb) {\n    readies[readies.length] = cb;\n}\n\nfunction define(name, fn) {\n    // This implies that the first module to be defined will be the \"root module\".\n    // It would be better if this were more explicit.\n    if (!queuedName) {\n        queuedName = name;\n    }\n    if (typeof(fn) == \"string\") {\n        frozen[name] = function() { return sandboxEval(fn).apply(this, arguments); }\n    } else {\n        frozen[name] = fn;\n    }\n}\nself.define = define;\n\n// *************************************************************************************************\n\nfunction thaw(name) {\n    var fn = frozen[name];\n    if (fn) {\n        delete frozen[name];\n\n        if (!mainModule) {\n            mainModule = name;    \n        }\n\n        var module = {id: name, exports: {}};\n        modules[name] = module;\n\n        var params = [require, module.exports, module];\n        fn.apply(self, params);\n\n        if (name == mainModule) {\n            for (var i = 0; i < readies.length; ++i) {\n                readies[i]();\n            }\n\n            if (has('appjs')) {\n                appjs.html = document.doctype + '\\n' + document.outerHTML;\n            }\n        }\n        return module.exports;\n    } else {\n        console.error('Module \"' + name + '\" not found');\n    }\n}\n\nif (self.addEventListener) {\n    self.addEventListener(\"DOMContentLoaded\", function() {\n        loaded = true;\n        thaw(queuedName);\n    });\n}\n\nself.startup = function(moduleName) {\n    loaded = true;\n    thaw(moduleName);\n}\n\n})();\n\nself.sandboxEval = function(js, sandbox) {\n    if (sandbox) {\n        with (sandbox) {\n            return eval(js);\n        }\n    } else {\n        return eval(js);\n    }\n};\n\n// XXXjoe has.js doesn't have a test for this yet :(\nif (self.document && !document.querySelector) {\n    (function(d){d=document,a=d.styleSheets[0]||d.createStyleSheet();d.querySelectorAll=function(e){a.addRule(e,'f:b');for(var l=d.all,b=0,c=[],f=l.length;b<f;b++)l[b].currentStyle.f&&c.push(l[b]);a.removeRule(0);return c}})();\n}\n"}